/*
  Test: Motor + Servo + Pressure + Flow Sensors (Sensor Reads at Cycle Start, Output Later)
  Devices:
    - 3x SparkFun MicroPressure Sensors (via Qwiic Mux)
    - YF-S201 Flow Sensor
    - NEMA23 Motor with Microstep Driver
    - 2x Servos (Mitral and Aortic Valve Simulation)
*/

#include <Wire.h>
#include <SparkFun_I2C_Mux_Arduino_Library.h>
#include <SparkFun_MicroPressure.h>
#include <Servo.h>

// Constants
const float PSI_TO_MMHG = 51.7149; // 1 psi = 51.7149 mmHg

// Mux and Pressure Sensor setup
QWIICMUX myMux;
const uint8_t muxAddress = 0x70;
const int sensorChannels[3] = {0, 2, 3};
SparkFun_MicroPressure pressureSensor;
float pressureValues[3];

// Flow sensor setup
const int flowPin = 3;
volatile int flowPulseCount = 0;
float calibrationFactor = 7.5;
float flowRate_mL_per_sec = 0;

// Stepper motor setup
const int stepPin = 5;
const int dirPin = 2;
const int enPin = 8;

unsigned long lastMotorStepMicros = 0;
const int motorStepsPerCycle = 400;
const unsigned long cycleLength = 857; // ms
unsigned long stepIntervalMicros = (cycleLength * 1000UL) / motorStepsPerCycle;
int motorStepCount = 0;

// Servo setup
Servo mitralValve;
Servo aorticValve;
const int mitralOpenAngle = 10;
const int mitralClosedAngle = 25;
const int aorticOpenAngle = 10;
const int aorticClosedAngle = 25;

const unsigned long mitralCloseTime = 492;
const unsigned long aorticOpenTime = 551;
const unsigned long aorticCloseTime = 807;
const unsigned long mitralOpenTime = 857;
unsigned long cycleStartTime = 0;

// Interrupt Service Routine for flow sensor
void flowISR() {
  flowPulseCount++;
}

// Read pressure sensor on a mux channel
float readPressureSensor(int channel) {
  myMux.setPort(channel);

  if (!pressureSensor.begin()) {
    return -1.0;
  }

  float pressure_psi = pressureSensor.readPressure();
  return pressure_psi * PSI_TO_MMHG;
}

void setup() {
  Serial.begin(9600);
  Wire.begin();

  if (!myMux.begin(muxAddress)) {
    while (1);
  }

  pinMode(flowPin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(flowPin), flowISR, RISING);

  pinMode(stepPin, OUTPUT);
  pinMode(dirPin, OUTPUT);
  pinMode(enPin, OUTPUT);

  digitalWrite(enPin, LOW);
  digitalWrite(dirPin, HIGH); // Fixed direction

  mitralValve.attach(9);
  aorticValve.attach(10);
  mitralValve.write(mitralOpenAngle);
  aorticValve.write(aorticClosedAngle);

  cycleStartTime = millis();
  lastMotorStepMicros = micros();
}

void loop() {
  unsigned long currentMillis = millis();
  unsigned long cycleTime = (currentMillis - cycleStartTime) % cycleLength;
  unsigned long nowMicros = micros();

  // Non-blocking Motor Step
  if (motorStepCount < motorStepsPerCycle && (nowMicros - lastMotorStepMicros >= stepIntervalMicros)) {
    digitalWrite(stepPin, HIGH);
    delayMicroseconds(10);
    digitalWrite(stepPin, LOW);
    lastMotorStepMicros = nowMicros;
    motorStepCount++;
  }

  // Valve (Servo) Control
  if (cycleTime < mitralCloseTime) {
    mitralValve.write(mitralOpenAngle);
  } else if (cycleTime < aorticOpenTime) {
    mitralValve.write(mitralClosedAngle);
  } else if (cycleTime >= mitralOpenTime) {
    mitralValve.write(mitralOpenAngle);
  }

  if (cycleTime < aorticOpenTime) {
    aorticValve.write(aorticClosedAngle);
  } else if (cycleTime < aorticCloseTime) {
    aorticValve.write(aorticOpenAngle);
  } else {
    aorticValve.write(aorticClosedAngle);
  }

  // Reset cycle and READ sensors immediately at cycle start
  if (currentMillis - cycleStartTime >= cycleLength) {
    cycleStartTime = currentMillis;
    motorStepCount = 0;

    // Synchronized sensor reads (cause jitters here)
    for (int i = 0; i < 3; i++) {
      pressureValues[i] = readPressureSensor(sensorChannels[i]);
    }

    noInterrupts();
    int count = flowPulseCount;
    flowPulseCount = 0;
    interrupts();

    float flowRate_L_per_min = count / calibrationFactor;
    flowRate_mL_per_sec = (flowRate_L_per_min * 1000) / 60.0;
  }

  // OUTPUT sensor values later in the loop (non-blocking)
  static unsigned long lastPrint = 0;
  if (currentMillis - lastPrint >= 200) {
    for (int i = 0; i < 3; i++) {
      Serial.print("Pressure Sensor ");
      Serial.print(i);
      Serial.print(": ");
      Serial.print(pressureValues[i]);
      Serial.println(" mmHg");
    }
    Serial.print("Flow Rate: ");
    Serial.print(flowRate_mL_per_sec);
    Serial.println(" mL/sec");
    lastPrint = currentMillis;
  }
}
