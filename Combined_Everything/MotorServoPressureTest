/*
  Test: Motor + Servo + Pressure Sensors
  Devices:
    - 3x SparkFun MicroPressure Sensors (via Qwiic Mux)
    - NEMA23 Motor with Microstep Driver
    - 2x Servos (Mitral and Aortic Valve Simulation)
*/

#include <Wire.h>
#include <SparkFun_I2C_Mux_Arduino_Library.h>
#include <SparkFun_MicroPressure.h>
#include <Servo.h>

// Constants
const float PSI_TO_MMHG = 51.7149; // 1 psi = 51.7149 mmHg

// Mux and Pressure Sensor setup
QWIICMUX myMux;
const uint8_t muxAddress = 0x70;
const int sensorChannels[3] = {0, 2, 3};
SparkFun_MicroPressure pressureSensor;
unsigned long lastPressureRead = 0;
const unsigned long pressureInterval = 500;

// Stepper motor setup
const int stepPin = 5;
const int dirPin = 2;
const int enPin = 8;

unsigned long lastMotorStepMicros = 0;
const int motorStepsPerCycle = 400;
const unsigned long cycleLength = 857; // ms
unsigned long stepIntervalMicros = (cycleLength * 1000UL) / motorStepsPerCycle;
int motorStepCount = 0;

// Servo setup
Servo mitralValve;
Servo aorticValve;
const int mitralOpenAngle = 10;
const int mitralClosedAngle = 25;
const int aorticOpenAngle = 10;
const int aorticClosedAngle = 25;

const unsigned long mitralCloseTime = 492;
const unsigned long aorticOpenTime = 551;
const unsigned long aorticCloseTime = 807;
const unsigned long mitralOpenTime = 857;
unsigned long cycleStartTime = 0;

// Read pressure sensor on a mux channel
float readPressureSensor(int channel) {
  myMux.setPort(channel);

  if (!pressureSensor.begin()) {
    Serial.print("Sensor on channel ");
    Serial.print(channel);
    Serial.println(" not detected.");
    return -1.0;
  }

  float pressure_psi = pressureSensor.readPressure();
  return pressure_psi * PSI_TO_MMHG;
}

void setup() {
  Serial.begin(9600);
  Wire.begin();

  if (!myMux.begin(muxAddress)) {
    Serial.println("Mux not detected!");
    while (1);
  }

  pinMode(stepPin, OUTPUT);
  pinMode(dirPin, OUTPUT);
  pinMode(enPin, OUTPUT);

  digitalWrite(enPin, LOW);
  digitalWrite(dirPin, HIGH); // Fixed direction

  mitralValve.attach(9);
  aorticValve.attach(10);
  mitralValve.write(mitralOpenAngle);
  aorticValve.write(aorticClosedAngle);

  cycleStartTime = millis();
  lastMotorStepMicros = micros();
  lastPressureRead = millis();
}

void loop() {
  unsigned long currentMillis = millis();
  unsigned long cycleTime = (currentMillis - cycleStartTime) % cycleLength;
  unsigned long nowMicros = micros();

  // Non-blocking Motor Step
  if (motorStepCount < motorStepsPerCycle && (nowMicros - lastMotorStepMicros >= stepIntervalMicros)) {
    digitalWrite(stepPin, HIGH);
    delayMicroseconds(10);
    digitalWrite(stepPin, LOW);
    lastMotorStepMicros = nowMicros;
    motorStepCount++;
  }

  // Valve (Servo) Control
  if (cycleTime < mitralCloseTime) {
    mitralValve.write(mitralOpenAngle);
  } else if (cycleTime < aorticOpenTime) {
    mitralValve.write(mitralClosedAngle);
  } else if (cycleTime >= mitralOpenTime) {
    mitralValve.write(mitralOpenAngle);
  }

  if (cycleTime < aorticOpenTime) {
    aorticValve.write(aorticClosedAngle);
  } else if (cycleTime < aorticCloseTime) {
    aorticValve.write(aorticOpenAngle);
  } else {
    aorticValve.write(aorticClosedAngle);
  }

  // Read Pressure Sensors (non-blocking)
  if (currentMillis - lastPressureRead >= pressureInterval) {
    for (int i = 0; i < 3; i++) {
      float pressure = readPressureSensor(sensorChannels[i]);
      Serial.print("Pressure Sensor ");
      Serial.print(i);
      Serial.print(": ");
      Serial.print(pressure);
      Serial.println(" mmHg");
    }
    lastPressureRead = currentMillis;
  }

  if (currentMillis - cycleStartTime >= cycleLength) {
    cycleStartTime = currentMillis;
    motorStepCount = 0;
  }
}
